# React Query

- https://tanstack.com/query/latest
- https://tanstack.com/query/latest/docs/framework/react/overview

## 1. 외부 API 연동라이브러리

- 용도는 외부 API 호출시 처리
- XHR, fetch, axios, Next 의 fetch 도 있음
- 또, React Query 까지 알아야 하나?
- React 프로젝트는 `axios` 와 `React Query` 가 필수
- Next 프로젝트는 `axios` 와 `React Query` 가 선택

## 2. React Query 가 필요로 한 이유 알아보기

- 사견 : Next.js 에서는 선택사항(fetch 사용시)

### 2.1. React 에서 axios 또는 fetch 를 이용한 호출의 경우

- 동일한 API 호출을 중복해서 여러번 호출함
- 캐싱이 없음
- 동기화 불가능
- 에러처리가 복잡함
- 로딩 상태 관리가 복잡함

### 2.2. React 에서 React Query 를 이용한 호출의 경우

- 자동 캐싱
- 중복 요청 방지
- 자동 동기화
- 간단한 에러처리
- 자동 로딩 상태 관리

## 3. React Query 란?

- 데이터를 쉽게 가져오고, 자동으로 데이터를 업데이트 해주는 도구
- `fresh 한 데이터` : 최신 데이터를 말함
- `stale 한 데이터` : 과거 데이터를 말함
- 서버 상태를 불러오고, 캐싱하며, 지속적으로 동기화하고, 업데이트하는 라이브러리

## 4. 설치

- 주의사항 : React Query 버전에 따라서 문법이 다름
- https://tanstack.com/query/latest/docs/framework/react/overview

```bash
npm install @tanstack/react-query @tanstack/react-query-devtools
```

## 5. 환경구성

### 5.1. React Query 설정

- `/src/lib/query-client.ts` 파일 생성

```ts
import { QueryClient } from '@tanstack/react-query';

/*
 핵심 내용 설정
 * 서버 상태 관리를 위한 모든 기능을 제공함
 * - 캐싱 : API 응답을 메모리에 저장하여 중복 요청 방지
 * - 동기화 : 서버와 클라이언트 상태 동기화
 * - 백그라운드 업데이트 : 데이터 자동 갱신
 * - 에러 처리 : 네트워크 오류 및 서버 오류 처리
 **/

export const queryClient = new QueryClient({
  defaultOptions: {
    // 데이터 읽기 관련 설정
    queries: {
      // 데이터가 오래된 것으로 간주하는 시간 (5분)
      staleTime: 5 * 60 * 1000,
      // 캐시에서 데이터를 제거하는 시간 (10분)
      gcTime: 10 * 60 * 1000,
      // 자동으로 데이터를 다시 가져오는 간격 (비활성화)
      refetchInterval: false,
      // 윈도우 포커스 시 자동 리페치 (활성화)
      refetchOnWindowFocus: true,
      // 네트워크 재연결시 자동 리페치 (활성화)
      refetchOnReconnect: true,
      // 에러 발생시 재시도 횟수 (3회)
      retry: 3,
      // 재시도 간격
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    // 데이터 수정 관련 설정
    mutations: {
      // 뮤테이션 에러 발생시 재시도 횟수 (1회)
      retry: 1,
      // 큐테이션 재시도 간격
      retryDelay: 1000,
    },
  },
});
```

## 5.2. Provider 설정

- `/src/components/providers` 폴더 생성
- `/src/components/providers/QueryProvider.tsx` 파일 생성

```tsx
/*
QueryClient 를 App 전체에 제공함
- 모든 하위 컴포넌트에서 useQuery, useMutaion 등의 훅을 사용할 수있게함
 **/
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools/production';
import { useState } from 'react';

export default function QueryProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // React 라면 아래 설정은 달라집니다.
  // 현재 Next.js 에다가 셋팅을 진행함.
  // 서버 사이드 렌더링을 위한 QueryClient 인스턴스 생성
  // 각 요청마다 새로운 QueryClient 를 생성하여 상태 구분함.
  const [client, setClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // 서버 사이드에서는 즉시 staleTime을 0으로 처리
            staleTime: 0,
            // 서버 사이드에서는 캐시하지 않음
            gcTime: 0,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      {/* npm run dev 상태에서만 개발자 도구 보기 */}
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools
          initialIsOpen={false}
          buttonPosition='bottom-right'
        />
      )}
    </QueryClientProvider>
  );
}
```

### 5.3. 앱 전체에 Provider 적용

- `/src/app/layout.tsx` 적용

```tsx
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import './globals.scss';
import QueryProvider from '@/components/providers/QueryProvider';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang='en'>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <QueryProvider>{children}</QueryProvider>
      </body>
    </html>
  );
}
```

## 6. API 설정하기

### 6.1. API 함수 만들기 (CRUD)

- 아래는 next.js에서 제공하는 api 와 혼돈 X
- `/src/lib/api.ts` 파일 생성

```ts
/**
 * API 함수들 - 서버와의 통신을 위한 함수들
 * 실제 API 호출을 담당하는 함수 정의
 * 실제 프로젝트에서는 axios, fetch 등을 사용해서 구현함.
 */

// 타입 정의
export interface User {
  id: number;
  name: string;
  email: string;
  phone: string;
  website: string;
  company: {
    name: string;
    catchPhrase: string;
    bs: string;
  };
}

export interface Post {
  id: number;
  userId: number;
  title: string;
  body: string;
}

export interface Comment {
  id: number;
  postId: number;
  name: string;
  email: string;
  body: string;
}

export interface Todo {
  id: number;
  userId: number;
  title: string;
  completed: boolean;
}

// 사용자 목록가져오기 API
export async function fetchUsers(): Promise<User[]> {
  // Vanila js 활용(Next.js 의 fetch 아님)
  const response = await fetch('https://jsonplaceholder.typicode.com/users');

  if (!response.ok) {
    throw new Error('사용자 목록 가져오기 실패');
  }

  return response.json();
}

// 특정 사용자 정보 가져오기
export async function fetchUser(id: number): Promise<User> {
  // Vanila js 활용(Next.js 의 fetch 아님)
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/users/${id}`
  );

  if (!response.ok) {
    throw new Error(`${id} 사용자 목록 가져오기 실패`);
  }

  return response.json();
}

// 게시글 목록 가져오기
// 전체 가져오기 기능
// 또는 각 사용자별 가져오기 기능
export async function fetchPosts(userId?: number): Promise<Post[]> {
  const url = userId
    ? `https://jsonplaceholder.typicode.com/posts?userId=${userId}`
    : 'https://jsonplaceholder.typicode.com/posts';

  // Vanila js 활용(Next.js 의 fetch 아님)
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`게시글 목록 가져오기 실패`);
  }

  return response.json();
}

// 특정 게시글 상세 정보를 가져오기
export async function fetchPost(id: number): Promise<Post> {
  // Vanila js 활용(Next.js 의 fetch 아님)
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`
  );

  if (!response.ok) {
    throw new Error(`${id} 게시글 상세정보 가져오기 실패`);
  }

  return response.json();
}

// 특정 게시글의 댓글 가져오기
export async function fetchComments(postId: number): Promise<Comment[]> {
  // Vanila js 활용(Next.js 의 fetch 아님)
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${postId}/comments`
  );

  if (!response.ok) {
    throw new Error(`${postId} 게시글 댓글 가져오기 실패`);
  }

  return response.json();
}

// 할일 목록 가져오기
export async function fetchTodos(userId?: number): Promise<Todo[]> {
  const url = userId
    ? `https://jsonplaceholder.typicode.com/todos?userId=${userId}`
    : 'https://jsonplaceholder.typicode.com/todos';

  const response = await fetch(url);

  if (!response.ok) {
    throw new Error('Failed to fetch todos');
  }

  return response.json();
}

// 새 게시글 생성하는 함수
export async function createPost(post: Omit<Post, 'id'>): Promise<Post> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(post),
  });

  if (!response.ok) {
    throw new Error('Failed to create post');
  }

  return response.json();
}

// 게시글 수정하는 함수
export async function updatePost(
  id: number,
  post: Partial<Post>
): Promise<Post> {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`,
    {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(post),
    }
  );

  if (!response.ok) {
    throw new Error(`Failed to update post ${id}`);
  }

  return response.json();
}

// 게시글 삭제하는 함수
export async function deletePost(id: number): Promise<void> {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`,
    {
      method: 'DELETE',
    }
  );

  if (!response.ok) {
    throw new Error(`Failed to delete post ${id}`);
  }
}
```

### 6.2. 사용자 관련 훅

- `/src/hooks` 폴더 생성
- `/src/hooks/useUsers.ts` 파일 생성

### 6.3. 게시글 관련 훅

- `/src/hooks/usePosts.ts` 파일 생성

### 6.4. 할일 관련 훅

- `/src/hooks/useTodos.ts` 파일 생성
